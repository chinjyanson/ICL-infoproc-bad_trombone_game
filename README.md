### Project Information

This project is a group coursework done in Year 2 Imperial EIE for Information Processing. We created a Unity game, that uses the accelerometer of the FPGA to play the game. Unfortunately the game will not work without 2 players and without FPGA's. To make up for that, you'll find below some images of our Project in action!


### Introduction and Purpose

Bad Trombone is a two player music rhythm game where players use FPGA to control visual cursors to match the rhythm bars of the song, and play an equivalent trombone sound as the bars are hit. The two players are able to play by looking at their own screen at different locations, choose between 3 music to play from together to compete with each other, and finally their player names and scores will be shown on a leaderboard for that song. The game is developed mainly using C# in Unity for the game client, Python for server scripts and C in Quartus for utilising the accelerometer sensor as well as detecting a button press on the FPGA board. AWS DynamoDB is utilised to store the leaderboard information for each song.

### System Architecture:

![sysarch](https://github.com/chinjyanson/ICL-infoproc-bad_trombone_game/blob/main/images/sysarch.jpg)

Above is an overall flowchart of the performance view and a diagram for the system design architecture of Bad Trombone, which can be broken down into the following 3 contributing sections:
FPGA controller
Back-end system of information transportation 
Game design using Unity 

### Overview of Components and Design Decisions

## FPGA Controller
# Overview of the FPGA Controller
There are three physical features on the FPGA that are utilised by the game: accelerometer sensor, key0 button and LED lights. FPGAs are tilted up and down by the players to control visual cursors in the game to match the rhythm bars of the song, by which the accelerometer sensor on each FPGA returns a value to determine its titling position. One button from the FPGA is used and its button press determines when the player is proceeding to the next scene of the game (ie from login scene to main game scene), and  when playing the musical game at the main scene, the player needs to press the button as the rhythm bars are hit by the cursor to score and play a trombone sound. The LED lights are used to correspond to the accelerometer sensor’s output value (ie the tilting of the FPGA) for visual debug purposes.

# Sending the FPGA data 
Both the accelerometer filtered data and the button trigger boolean value are transmitted to the PC client using a python script running on the PC upon request. The python code interfaces with the nios processor via the JTAG-UART port. When necessary, it sends the string "Plotting" to the NIOS terminal to activate plotting mode. Meanwhile, the processor is equipped with an interrupt linked to the UART port, which activates whenever a string is received in the buffer sent from Python code. Upon activation and transition to plotting mode, the NIOS2 processor transmits a string of accelerometer data, appended with a space and the boolean value indicating whether the button is pressed, to the Python code, again received through the JTAG/UART interface. Subsequently, this client python code does the process of the received information from FPGA, unpacks it from the string, and repackages it for transmission to the server using the Python struct library. 

## Backend system of information transportation
# Overview of the server on AWS Cloud 
The back-end system, consisting of one server hosted on the Amazon Elastic Compute Cloud instances (EC2), is written in python to transfer information across multiple clients. It uses socket and threading libraries to manage TCP requests from multiple clients and exchange data efficiently. The server simultaneously communicates with four clients: two FPGA PC clients and two Unity clients. Additionally, it interacts with the Amazon DynamoDB database to access and update information as needed. To ensure smooth operation and minimise packet loss and traffic congestion, the system opens four main threads, each operating on a unique port, creating its individual TCP welcoming sockets, binding and listening to its corresponding client. The server also utilises global variables that serve as a centralised mechanism for exchanging and synchronising important data such as player position and button presses between different threads. Having multiple threads operating on unique ports also allow for easier debugging as different types of calls to the server are assigned a specific port and nodes causing issues during testing can be isolated.

# Interaction between the server with its FPGA clients
This game uses two FPGA nodes on two different computers with local python code (fpga.py) that establish connections to the corresponding ports on the server and transmit the required information as needed. The python struct library is used to pack the data into the smallest possible size in byte format to be transmitted over TCP for lower bandwidth usage and faster transmission speed. By utilising this library, both the accelerometer value and the button press indicator value is sent in one packet instead of two to eliminate redundancy of transmitting multiple separate packets, hence increasing its efficiency. 

#  Interaction between the server and Unity game client 
Similarly, one port is used specifically for communication between the Unity clients and the central server. A single main thread is employed and binded to the port and acts as a reception of TCP requests from different players on Unity. Due to the nature of this game, which allows two players to participate simultaneously from different locations and devices, this main thread is crucial for managing concurrent communication streams. Upon successful connection to the server, each player’s Unity client is assigned a unique connection socket and a new thread will be initialised, allowing for simultaneous handling of game clients. Through this connection, individual clients then receive updates regarding their gameplay status, including button press indications, cursor movement updates and score changes during the game. After the game ends, the Unity client sockets will be closed and the server will be ready to accept new connections again for a new game.

# Using the AWS DynamoDB
The system stores music note information and user scores in AWS DynamoDB. Musical note information for the three songs are initially generated as MIDI files through a digital music editor and converted into JSON string using a python script. The JSON strings are loaded into the database at server initialisation. They are retrieved by the Unity client after song selection via TCP . After the game ends, each player’s username and score will be saved to the score database for that particular song, and the top five player’s name and scores will be retrieved and sent to the game to display the leaderboard.

## Game Design

<a href="url"><img src="https://github.com/chinjyanson/ICL-infoproc-bad_trombone_game/blob/main/images/starting.png" align="left" height="250" ></a>
<a href="url"><img src="https://github.com/chinjyanson/ICL-infoproc-bad_trombone_game/blob/main/images/loadingsong.png" align="left" height="250" ></a>
<a href="url"><img src="https://github.com/chinjyanson/ICL-infoproc-bad_trombone_game/blob/main/images/maingame.png" align="left" height="250" ></a>
<a href="url"><img src="https://github.com/chinjyanson/ICL-infoproc-bad_trombone_game/blob/main/images/finalscene.png" align="left" height="250" ></a>

## Game Description
The Starting Screen consists of a player prompt and a start button. Through a TCP connection, the entered player_name will be sent to the server and the server will return a player number to the game client. Whoever is the first to send the player name to the server will be named player 1 and remain that way until the game ends.

The game then changes scenes using the Unity View Manager to go to the Loading Song Scene. This scene includes a button to choose the song, a text display and a Ready text. The middle display text will change to inform the player of the other player’s song choice to facilitate communication between the players as they have to agree on the same song. The players will then have to indicate that they are ready to proceed by holding down the button on their FPGA controllers, and the Ready text will turn green to show when each player is ready.

After both players are ready to proceed, the music note information stored in the database is sent via TCP to the local unity game manager as a JSON string and the game will transition to its Main Game Scene, where the players will be able to control their cursors on the screen through FPGA to play. The main game involves players controlling circular cursors on the screen through FPGA aiming to hit the note coming from the right of the screen and a trombone sound of the corresponding note will be played when hit. Players receive a score for each note hit.  Each player controls their own cursor, but will be able to see the position and the actions of the other player on their screen.

When the main game scene starts, the music note information, including song name, tempo and note position, note length, start pitch of each note is parsed from the JSON string and stored in NoteData class in unity game manager. Each note is generated as a clone of the note prefab and arranged on the screen based on its starting pitch, duration, and position, as well as the song's tempo specified in the JSON string. To place the note at the correct position according to the song, each note is timed to wait a certain time, calculated through its position and tempo of the song after the last note was created. Additionally, its y-axis position is calculated from its pitch and proportionally scaled to fit the size of the window. The cursor positioned on the leftmost of the screen handles the note triggering. Its position is converted from the accelerometer value of the FPGA and gets updated in each frame of the game, while the hitting action corresponds to the button input of the FPGA. The hitting mechanism is such that a note is played when the cursor collides with a note while the player is holding the button. The cursor has two functions for handling the note triggering. HittingStart() is called by the OnCollisionStay2D() provided by Unity which is called every frame to determine if two objects with specific tags ‘note’ and ‘cursor’ are colliding. HittingEnd() is called by OnCollisionExit2D() in Unity which is called when two objects stop colliding. Boolean valuable Hitting is passed through the collision functions and describes the hitting state. So HittingEnd() is also called in OnCollisionStay2D() when the button is not pressed and boolean hitting is true. This makes sure hitting happens when the objects are colliding at the same time the player is holding the button. To play the sound, the HittingStart() and HittingEnd() calls a trombone game object which stores the trombone audio samples from c2 to c4 and plays the audio based on note it collides with, at a specific pitch. This scene includes a scoreboard which will increment when the cursors and the notes hit each other and when the button on the FPGA is pressed. The getScore() function is called the same way as HandleHitStart() when a player hits a note.

In this section of the game, information on player positions and button presses must be sent rapidly from the FPGA to the server and to the Unity client, and any delay will negatively impact player experience, especially since timing is crucial in this game. The python struct library was therefore employed again in the server to pack the position of the two players and their button presses into the minimum 6 bytes (two boolean and two short) and sent to the client, which will unpack it in equivalent C# code. Another issue was the difference in the rates at which the FPGA sends information to the server and the rate at which the client updates the screen. As TCP operates as a connection-oriented data stream, if incoming information is sent faster than the rate at which it is read, it would lead to a build-up in the queue that results in an observable delay. To overcome this issue, the sending of data from the FPGA and to the clients operate on separate threads in the server, with global variables to transfer information between threads. The Unity clients utilise a ‘ping’ system where they send a request to the server at each frame and receive the latest position and button data, hence minimising delay.

Another important consideration made was in how scores are synced across the two different player clients. As scores are calculated based on interactions of game objects within each Unity client, it is possible for the scores to be calculated differently in the two clients due to the minor differences in when requests are made for player position over the server. In order to sync the scores in a way that is fair to what each player is seeing on their screens, the game client will send the current score of the player playing to the server during the game. At the same time, the client will retrieve the score of the other player to be shown on the screen. This ensures that during the whole game, the score shown for each player on both screens will be synchronised while at the same time making it so that the score changes accurately reflect the player’s actions. The sending and receiving of score information also runs on a different thread in the client and server with a separate socket to avoid interference with the sending of positional data.

After the game ends, the game transitions to the Final Scene. Here, the score of each player is shown. The leaderboard for the song as well as the player’s best score so far is shown. There is a button to replay which will move the game back to the Starting Screen.






